"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var models_1 = require("../../../common/models");
var authorizer_1 = require("../authorizer/authorizer");
var password_1 = require("../../utils/password/password");
var StoreAuthorizer = (function (_super) {
    tslib_1.__extends(StoreAuthorizer, _super);
    function StoreAuthorizer(options) {
        var _this = this;
        var getRoleStore = options.getRoleStore;
        _this = _super.call(this) || this;
        _this.userStore = options.userStore;
        _this.getRoleStore = getRoleStore;
        _this.authStore = options.authStore;
        return _this;
    }
    StoreAuthorizer.prototype.updateWithTrustedUser = function (trustedUser) {
        return authorizer_1.Authorizer.updateUserStoreFromSourceOfTruth(this.userStore, trustedUser, true);
    };
    StoreAuthorizer.prototype.checkUser = function (userName, password) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, userStore, authStore, userAuth, equals, user;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, userStore = _a.userStore, authStore = _a.authStore;
                        if (!authStore)
                            throw new Error('not configured to authorize users');
                        return [4, authStore.get(userName)];
                    case 1:
                        userAuth = _b.sent();
                        if (!userAuth)
                            return [2, null];
                        return [4, password_1.checkPassword(userAuth, password)];
                    case 2:
                        equals = _b.sent();
                        if (!equals)
                            return [2, null];
                        return [4, userStore.get(userName)];
                    case 3:
                        user = _b.sent();
                        return [2, user];
                }
            });
        });
    };
    StoreAuthorizer.prototype.changePassword = function (user, newPassword) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authStore, userAuth, updatedUserAuth;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        authStore = this.authStore;
                        if (!authStore)
                            throw new Error('not configured to manege passwords users');
                        return [4, authStore.get(user)];
                    case 1:
                        userAuth = _a.sent();
                        if (!userAuth)
                            userAuth = new models_1.UserAuth({ name: user, pass: null });
                        return [4, password_1.updatePassword(userAuth, newPassword)];
                    case 2:
                        updatedUserAuth = _a.sent();
                        return [4, authStore.addOrUpdate(updatedUserAuth)];
                    case 3:
                        _a.sent();
                        return [2, true];
                }
            });
        });
    };
    StoreAuthorizer.prototype.deleteUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.userStore.deleteByKey(user)];
                    case 1:
                        _a.sent();
                        return [2, this.authStore.deleteByKey(user)];
                }
            });
        });
    };
    StoreAuthorizer.prototype.addOrUpdateUser = function (user) {
        return this.userStore.addOrUpdate(user);
    };
    StoreAuthorizer.prototype.getUser = function (name) {
        return this.userStore.get(name);
    };
    StoreAuthorizer.prototype.getUserWithRoles = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, roleStore, roles;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.getUser(name)];
                    case 1:
                        user = _a.sent();
                        if (!user)
                            return [2, null];
                        if (!this.getRoleStore) {
                            throw new Error("getRoleStore is not defined");
                        }
                        roleStore = this.getRoleStore(user);
                        if (!roleStore) {
                            throw new Error("Could not get role store");
                        }
                        return [4, roleStore.getAll()];
                    case 2:
                        roles = _a.sent();
                        return [2, user.attachActualRoles(roles)];
                }
            });
        });
    };
    StoreAuthorizer.prototype.getAllUsers = function () {
        return this.userStore.getAll();
    };
    StoreAuthorizer.prototype.isManagingUsers = function () {
        return Boolean(this.authStore);
    };
    StoreAuthorizer.prototype.isManagingRoles = function () {
        return Boolean(this.getRoleStore);
    };
    StoreAuthorizer.prototype.applyUserDiff = function (diff) {
        return this.userStore.applyDiff(diff);
    };
    StoreAuthorizer.prototype.userSize = function () {
        return this.userStore.size();
    };
    StoreAuthorizer.prototype.userAuthSize = function () {
        return this.authStore.size();
    };
    StoreAuthorizer.prototype.getAllRoles = function (user) {
        var roleStore = this.getRoleStore(user);
        if (!roleStore) {
            throw new Error("Could not get role store");
        }
        return roleStore.getAll();
    };
    StoreAuthorizer.prototype.applyRoleDiff = function (diff, user) {
        var roleStore = this.getRoleStore(user);
        if (!roleStore) {
            throw new Error("Could not get role store");
        }
        return roleStore.applyDiff(diff);
    };
    return StoreAuthorizer;
}(authorizer_1.Authorizer));
exports.StoreAuthorizer = StoreAuthorizer;
