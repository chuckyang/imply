"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var express = require("express");
var beltful_1 = require("@implydata/beltful");
var response_status_1 = require("../../../common/utils/response-status/response-status");
function trackLoginAttempt(tracker, userEmail, success, statusText) {
    tracker.track({
        type: 'login-attempt',
        metric: 'login-attempt/count',
        value: 1,
        user: null,
        attr: {
            success: String(success),
            user_email: userEmail,
            status_text: statusText
        }
    });
}
function loginRouterFactory(options) {
    var _this = this;
    var mainDomain = options.mainDomain, subdomainGetter = options.subdomainGetter;
    var router = express.Router();
    router.use(function (req, res, next) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var logger, authorizer, _a, name, pass, rememberMe, trackWithTracker, subdomain, mainDomainUrl, subdomains, user, e_1, mainDomainUrl, expectedSubdomain, e_2;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    logger = req.logger, authorizer = req.authorizer;
                    if (!req.body) {
                        next();
                        return [2];
                    }
                    _a = req.body, name = _a.name, pass = _a.pass, rememberMe = _a.rememberMe;
                    trackWithTracker = function (statusText) { return trackLoginAttempt(req.tracker, name, statusText === response_status_1.ResponseStatus.OK, statusText); };
                    if (subdomainGetter) {
                        mainDomainUrl = beltful_1.ImmutableURL.fromJS(req.get('host'))
                            .changeProtocol(req.protocol)
                            .changeHostName(mainDomain);
                        subdomains = req.subdomains;
                        if (!subdomains || !subdomains.length || subdomains.length > 1) {
                            logger.log('Could not figure out subdomain');
                            trackWithTracker('NO_SUBDOMAIN_REDIRECT');
                            res.status(400).json({
                                status: response_status_1.ResponseStatus.REDIRECT,
                                message: 'redirect',
                                href: mainDomainUrl
                            });
                            return [2];
                        }
                        subdomain = subdomains[0].toLowerCase();
                    }
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4, authorizer.checkUser(name, pass)];
                case 2:
                    user = _b.sent();
                    return [3, 4];
                case 3:
                    e_1 = _b.sent();
                    trackWithTracker('BAD_AUTH');
                    res.status(401).json({ status: 'BAD_AUTH' });
                    return [2];
                case 4:
                    if (!user) {
                        trackWithTracker('INVALID_USER');
                        res.status(401).json({ status: 'INVALID_USER' });
                        return [2];
                    }
                    if (authorizer.hasAccounts() && !user.accountId) {
                        trackWithTracker('NO_ACCOUNT');
                        res.status(500).json({ status: 'User must have account id' });
                        return [2];
                    }
                    if (!subdomainGetter) return [3, 9];
                    mainDomainUrl = beltful_1.ImmutableURL.fromJS(req.get('host'))
                        .changeProtocol(req.protocol)
                        .changeHostName(mainDomain);
                    expectedSubdomain = void 0;
                    _b.label = 5;
                case 5:
                    _b.trys.push([5, 7, , 8]);
                    return [4, subdomainGetter(user)];
                case 6:
                    expectedSubdomain = _b.sent();
                    return [3, 8];
                case 7:
                    e_2 = _b.sent();
                    logger.log("Could not get subdomain for account id: " + user.accountId + ", user: " + user.name);
                    trackWithTracker('SUBDOMAIN_GETTING_ERROR');
                    res.status(401).json({ status: response_status_1.ResponseStatus.BAD_AUTH });
                    return [2];
                case 8:
                    if (!expectedSubdomain) {
                        logger.log("Empty subdomain for: " + user.accountId + ", user: " + user.name);
                        trackWithTracker('NULL_SUBDOMAIN');
                        res.status(401).json({ status: response_status_1.ResponseStatus.BAD_AUTH });
                        return [2];
                    }
                    expectedSubdomain = expectedSubdomain.toLowerCase();
                    if (expectedSubdomain !== subdomain) {
                        logger.log("Wrong subdomain: redirecting to: " + expectedSubdomain + "." + mainDomainUrl);
                        trackWithTracker('SUBDOMAIN_REDIRECT');
                        res.status(400).json({
                            status: response_status_1.ResponseStatus.REDIRECT,
                            message: 'redirect',
                            href: beltful_1.ImmutableURL.fromJS(req.get('host'))
                                .changeProtocol('http')
                                .changeHostName(expectedSubdomain + '.' + mainDomain)
                                .toString()
                                .replace('http://', '//')
                        });
                        return [2];
                    }
                    _b.label = 9;
                case 9:
                    req.session.loggedIn = true;
                    req.session.userName = user.name;
                    if (rememberMe) {
                        req.session.cookie.maxAge = 2592000000;
                    }
                    trackWithTracker(response_status_1.ResponseStatus.OK);
                    res.status(200).json({ status: response_status_1.ResponseStatus.OK });
                    return [2];
            }
        });
    }); });
    return router;
}
exports.loginRouterFactory = loginRouterFactory;
