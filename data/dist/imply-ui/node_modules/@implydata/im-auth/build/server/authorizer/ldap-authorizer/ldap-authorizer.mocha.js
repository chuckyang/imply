"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chai_1 = require("chai");
var ldap_authorizer_1 = require("./ldap-authorizer");
var spawnServer = require("node-spawn-server");
var immutable_store_1 = require("@implydata/immutable-store");
var models_1 = require("../../../common/models");
function spawnServerHook(cmd, hook, verbose) {
    if (verbose === void 0) { verbose = false; }
    return new Promise(function (resolve, reject) {
        spawnServer(cmd, { verbose: verbose }).onHook(hook, resolve);
    });
}
describe('LDAP authorizer', function () {
    var _this = this;
    this.timeout(35000);
    var roleStore = new immutable_store_1.ArrayStore({
        initArray: [
            new models_1.Role({
                name: 'restricted',
                permissions: [
                    {
                        name: 'create-file',
                        value: '*'
                    },
                    {
                        name: 'edit-file',
                        value: '*'
                    }
                ]
            })
        ]
    });
    var userStore1;
    var userStore2;
    var ldapAuthorizer1;
    var ldapAuthorizer2;
    before(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, spawnServerHook('script/ldap/docker-init', 'started ldap')];
                case 1:
                    _a.sent();
                    userStore1 = new immutable_store_1.ArrayStore({});
                    ldapAuthorizer1 = new ldap_authorizer_1.LDAPAuthorizer({
                        roleAuthority: 'ldap',
                        userStore: userStore1,
                        roleStore: roleStore,
                        ldapOptions: {
                            url: 'ldap://192.168.99.100:389',
                            searchBase: "dc=imply,dc=io",
                            searchFilter: "(uid={{username}})",
                            bindDN: 'cn=admin,dc=imply,dc=io',
                            bindCredentials: 'JonSn0w',
                            timeout: 3000
                        }
                    });
                    userStore2 = new immutable_store_1.ArrayStore({});
                    ldapAuthorizer2 = new ldap_authorizer_1.LDAPAuthorizer({
                        roleAuthority: 'ldap',
                        userStore: userStore2,
                        roleStore: roleStore,
                        ldapOptions: {
                            url: 'ldap://192.168.99.100:389',
                            searchBase: "dc=imply,dc=io",
                            searchFilter: "(uid={{username}})",
                            bindDN: 'cn=admin,dc=imply,dc=io',
                            bindCredentials: 'JonSn0w',
                            timeout: 3000
                        },
                        rolesKey: 'description',
                        defaultRole: 'restricted'
                    });
                    return [2];
            }
        });
    }); });
    after(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, spawnServerHook('script/ldap/docker-teardown', 'removed ldap')];
                case 1:
                    _a.sent();
                    return [2];
            }
        });
    }); });
    it("invalid auth", function () {
        var ldapAuthorizer = new ldap_authorizer_1.LDAPAuthorizer({
            roleAuthority: 'ldap',
            userStore: new immutable_store_1.ArrayStore({}),
            roleStore: roleStore,
            ldapOptions: {
                url: 'ldap://192.168.99.100:38999',
                searchBase: "dc=imply,dc=io",
                searchFilter: "(uid={{username}})",
                bindDN: 'cn=admin,dc=imply,dc=io',
                bindCredentials: 'JonSn0w'
            }
        });
        return ldapAuthorizer.checkUser('jackRipper', 'jack.the.ripper')
            .then(function () {
            throw new Error('DID_NOT_THROW');
        })
            .catch(function (e) {
            chai_1.expect(e.message).to.equal('LDAP error');
        });
    });
    it("does valid user", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4, ldapAuthorizer1.checkUser('jackRipper', 'jack.the.ripper')];
                case 1:
                    valid = _b.sent();
                    chai_1.expect(valid.toJS()).to.deep.equal({
                        "firstName": "jack",
                        "lastName": "Ripper",
                        "name": "jackRipper",
                        "roles": ["super-admin"],
                        "status": "ok"
                    });
                    _a = chai_1.expect;
                    return [4, ldapAuthorizer1.getUser('jackRipper')];
                case 2:
                    _a.apply(void 0, [(_b.sent()).toJS()]).to.deep.equal({
                        "firstName": "jack",
                        "lastName": "Ripper",
                        "name": "jackRipper",
                        "roles": ["super-admin"],
                        "status": "ok"
                    });
                    return [2];
            }
        });
    }); });
    it("does not allow bad pass", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, ldapAuthorizer1.checkUser('jackRipper', 'bad.the.ripper')];
                case 1:
                    valid = _a.sent();
                    chai_1.expect(valid).to.equal(null);
                    return [2];
            }
        });
    }); });
    it("does not allow non existent user", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, ldapAuthorizer1.checkUser('jackRipperIsCool', 'jack.the.ripper')];
                case 1:
                    valid = _a.sent();
                    chai_1.expect(valid).to.equal(null);
                    return [2];
            }
        });
    }); });
    it("throws with bad bind info", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var badLdapAuthorizer, err_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    badLdapAuthorizer = new ldap_authorizer_1.LDAPAuthorizer({
                        roleAuthority: 'ldap',
                        userStore: new immutable_store_1.ArrayStore({}),
                        roleStore: roleStore,
                        ldapOptions: {
                            url: 'ldap://192.168.99.100:389',
                            searchBase: "ddc=imply,dc=io",
                            searchFilter: "(uid={username}})",
                            bindDN: '###########',
                            bindCredentials: 'JonSn0w'
                        }
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, badLdapAuthorizer.checkUser('jackRipper', 'bad.the.ripper')];
                case 2:
                    _a.sent();
                    return [3, 4];
                case 3:
                    err_1 = _a.sent();
                    chai_1.expect(err_1.message).to.equal('invalid DN');
                    return [3, 4];
                case 4: return [2];
            }
        });
    }); });
    it("does valid (default) restricted user", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, ldapAuthorizer2.checkUser('marcelTheShell', 'shoes')];
                case 1:
                    valid = _a.sent();
                    chai_1.expect(valid.toJS()).to.deep.equal({
                        "firstName": "marcel",
                        "lastName": "Shell",
                        "name": "marcelTheShell",
                        "roles": ["restricted"],
                        "status": "ok"
                    });
                    return [2];
            }
        });
    }); });
    it("does valid role-ed user", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, ldapAuthorizer2.checkUser('scoops', 'big.bang.theory')];
                case 1:
                    valid = _a.sent();
                    chai_1.expect(valid.toJS()).to.deep.equal({
                        "firstName": "sheldon",
                        "lastName": "Cooper",
                        "email": "sheldon@imply.io",
                        "name": "scoops",
                        "roles": ["super-admin"],
                        "status": "ok"
                    });
                    return [2];
            }
        });
    }); });
    it("does valid two role-ed user", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, ldapAuthorizer2.checkUser('porkHam', 'pork.is.great')];
                case 1:
                    valid = _a.sent();
                    chai_1.expect(valid.toJS()).to.deep.equal({
                        "firstName": "shauna",
                        "lastName": "Ham",
                        "name": "porkHam",
                        "roles": [
                            "role1",
                            "role2"
                        ],
                        "status": "ok"
                    });
                    return [2];
            }
        });
    }); });
    it("works after restart", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var valid;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, spawnServerHook('script/ldap/docker-teardown', 'removed ldap')];
                case 1:
                    _a.sent();
                    return [4, ldapAuthorizer2.checkUser('jackRipper', 'jack.the.ripper')
                            .then(function () {
                            throw new Error("did not error 1");
                        })
                            .catch(function (e) {
                            chai_1.expect(e.message).to.equal('LDAP error');
                        })];
                case 2:
                    _a.sent();
                    return [4, spawnServerHook('script/ldap/docker-init', 'started ldap')];
                case 3:
                    _a.sent();
                    return [4, ldapAuthorizer2.checkUser('jackRipper', 'jack.the.ripper')];
                case 4:
                    valid = _a.sent();
                    chai_1.expect(valid.toJS()).to.deep.equal({
                        "firstName": "jack",
                        "lastName": "Ripper",
                        "name": "jackRipper",
                        "roles": ["restricted"],
                        "status": "ok"
                    });
                    return [2];
            }
        });
    }); });
});
