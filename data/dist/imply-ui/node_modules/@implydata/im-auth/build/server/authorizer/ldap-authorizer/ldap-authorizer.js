"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var LdapAuth = require("ldapauth-fork");
var models_1 = require("../../../common/models");
var authorizer_1 = require("../authorizer/authorizer");
var LDAPAuthorizer = (function (_super) {
    tslib_1.__extends(LDAPAuthorizer, _super);
    function LDAPAuthorizer(options) {
        var _this = _super.call(this) || this;
        _this.rejects = [];
        _this.roleAuthority = options.roleAuthority;
        _this.userStore = options.userStore;
        _this.roleStore = options.roleStore;
        _this.ldapOptions = options.ldapOptions;
        _this.rolesKey = options.rolesKey;
        if (options.defaultRole) {
            _this.defaultRole = options.defaultRole;
            if (typeof _this.defaultRole !== 'string')
                throw new Error("defaultRole must be a string");
        }
        else {
            _this.defaultRole = 'super-admin';
        }
        _this.logger = options.logger;
        return _this;
    }
    LDAPAuthorizer.prototype.bindLdapIfNeeded = function () {
        var _this = this;
        if (this.ldapAuth)
            return;
        this.ldapAuth = new LdapAuth(this.ldapOptions);
        this.ldapAuth.on('error', function (e) {
            _this.handleError(e);
        });
    };
    LDAPAuthorizer.prototype.handleError = function (e) {
        if (!this.ldapAuth)
            return;
        if (e && this.logger)
            this.logger.error("LDAP Error: " + e.message + " ");
        this.ldapAuth.close();
        this.ldapAuth = null;
        this.rejects.forEach(function (reject) { return reject(new Error('LDAP error')); });
        this.rejects = [];
    };
    LDAPAuthorizer.prototype.checkUser = function (userName, password) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _a, userStore, rolesKey, defaultRole, ldapUserPromise, ldapUser;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, userStore = _a.userStore, rolesKey = _a.rolesKey, defaultRole = _a.defaultRole;
                        this.bindLdapIfNeeded();
                        ldapUserPromise = new Promise(function (resolve, reject) {
                            _this.rejects.push(reject);
                            var timeout = setTimeout(function () {
                                _this.handleError(new Error('op timeout'));
                            }, 3000);
                            _this.ldapAuth.authenticate(userName, password, function (err, matched) {
                                clearTimeout(timeout);
                                _this.rejects = _this.rejects.filter(function (r) { return r !== reject; });
                                if (err) {
                                    if ((typeof err === 'string' && err.startsWith('no such user:')) || [48, 49, 50, 66].includes(err.code)) {
                                        resolve(null);
                                    }
                                    else {
                                        reject(err);
                                    }
                                    return;
                                }
                                var roles = [defaultRole];
                                var rolesValue = matched[rolesKey];
                                if (typeof rolesValue === 'string') {
                                    roles = rolesValue.split(',').map(function (s) { return s.trim(); });
                                }
                                resolve(new models_1.User({
                                    name: userName,
                                    firstName: matched['cn'] || null,
                                    lastName: matched['sn'] || null,
                                    email: matched['email'] || null,
                                    status: 'ok',
                                    roles: roles
                                }));
                            });
                        });
                        return [4, ldapUserPromise];
                    case 1:
                        ldapUser = _b.sent();
                        if (!ldapUser)
                            return [2, null];
                        return [2, authorizer_1.Authorizer.updateUserStoreFromSourceOfTruth(userStore, ldapUser, this.roleAuthority === 'ldap')];
                }
            });
        });
    };
    LDAPAuthorizer.prototype.getUser = function (name) {
        return this.userStore.get(name);
    };
    LDAPAuthorizer.prototype.getUserWithRoles = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, roles;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.getUser(name)];
                    case 1:
                        user = _a.sent();
                        if (!user)
                            return [2, null];
                        return [4, this.roleStore.getAll()];
                    case 2:
                        roles = _a.sent();
                        return [2, user.attachActualRoles(roles)];
                }
            });
        });
    };
    LDAPAuthorizer.prototype.getAllUsers = function () {
        return this.userStore.getAll();
    };
    LDAPAuthorizer.prototype.addOrUpdateUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser, newUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.userStore.get(user.name)];
                    case 1:
                        currentUser = _a.sent();
                        if (!currentUser)
                            throw new Error('Unknown user');
                        newUser = currentUser.changeFavorites(user.favorites);
                        return [2, this.userStore.addOrUpdate(newUser)];
                }
            });
        });
    };
    LDAPAuthorizer.prototype.userSize = function () {
        return this.userStore.size();
    };
    LDAPAuthorizer.prototype.isManagingRoles = function () {
        return true;
    };
    LDAPAuthorizer.prototype.getAllRoles = function () {
        return this.roleStore.getAll();
    };
    LDAPAuthorizer.prototype.applyRoleDiff = function (diff) {
        if (this.roleAuthority !== 'native') {
            throw new Error("Can only modify roles if role management is native");
        }
        return this.roleStore.applyDiff(diff);
    };
    return LDAPAuthorizer;
}(authorizer_1.Authorizer));
exports.LDAPAuthorizer = LDAPAuthorizer;
